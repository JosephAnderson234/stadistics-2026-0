---
title: "04_Estadistica_Básica"
author: "Orlando Galarza"
format: 
  html:
    toc: true
    toc-depth: 2
    number-sections: true
    theme: flatly        
    highlight-style: tango
    code-fold: false
    code-tools: false
    df-print: paged
    smooth-scroll: true
    link-external-newwindow: true
    embed-resources: true
editor: visual
---

## Quarto

```{r}
library(readr)
library(plyr)
library(dplyr)
library(tidyr)
library(tidyverse)
library(ggplot2)
```

&&&&&&&&&&&&&&&&&&&&&&&&&

Recordar que se tiene las datas:

**DD** (Datos diversos).

**DDP** (es DD, pero corrigiendo el tipo de variable y tambien los nombres de las variables).

```{r}
DD<-read_csv("datos_diversos.csv")
DD
DDP <- DD
```

# La función select

Cuando se tiene un *data frame* con muchas variables (columnas) muchas veces queremos analizar solo a algunas de ellas. Esto se puede hacer usando la función ***select***, que nos permite tomar un subconjunto de variables (columnas) y obtener un nuevo data frame.

Revisando DDP:

```{r}
names(DDP) # para ver los nombres de las columnas
```

Se observa que las últimas 5 columnas están por las puras.

**Ejemplos de select**

```{r}
DDP2<-select(DDP, Edad, Ciclo, Período)
DDP2
# Aquí se está seleccionando de DDP, cinco columnas.
```

Para seleccionar varias columnas consecutivas:

Otra forma es colocando un rango de valores con el nombre de una variable inicial, seguido de ***2 puntos*** y luego el nombre de una variable final.

Primero debo ver los nombres de las columnas. para ello se usa ***names***

```{r}
names(DDP)
```

**Ahora sí, eliminamos aquí las 5 columnas finales inútiles.**

```{r}
DDP1<- select(DDP, "Período" : "Indicaciones")
DDP1   # Este DF ha seleccionado a todas las columnas útiles. 
```

Este DDP1 ahora ya tiene todas las columnas útiles ya que se ha eliminado las inútiles de la 19 a la 23.

**DDP1 lo seguiremos usando luego. (ya no contiene columnas inútiles).**

Tendrá Filas completas nuestro nuevo DF?

```{r}
sum(complete.cases(DDP1))
```

Hay 1342 filas completas. es decir 1342 alumnos han llenado todas las variables útiles.

# Eliminando variables (otras formas con select)

Vamos a eliminar columnas en forma directa usando DDP (que contiene aun las columnas inutiles)

```{r}
DDP3<- DDP [,-23]  # se está quitando la columna 23
DDP3
```

Otra forma:

```{r}
DDP4<- select(DDP, -...19, -...20, -...21, -...22, -...23)
DDP4
```

Se obtuvo una data semejante a DDP1 (ya está sin las columnas inútiles)

**DDP4= DDP1**

%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%

Otra forma:

```{r}
glimpse(DDP4)
```

```{r}
names(DDP1)
```

Se puede eliminar

```{r}
DDP4$`Talla de zapato`<- NULL
DDP4
```

Ejemplo para eliminar columnas consecutivas: \[,5\]

```{r}
DDP5<-DDP4 [,-3: -7]
DDP5
```

El comando ***\`select\`*** tiene otras aplicaciones en relación a la selección de variables. Pueda buscar patrones, es decir que los nombres de las variables tengan algo en común. En estos casos se pueden utilizar los argumentos \`starts_with("")\`, \`ends_with("")\`, \`contains("")\`

```{r}
DDP6<-select(DDP1, starts_with("T"))
DDP6
```

También:

```{r}
DDP7<- select(DDP1, ends_with("o"))
DDP7
```

```{r}
DDP8<- select(DDP2, contains("_"))
DDP8
```

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

-   ***Select: sirve para seleccionar columnas o eliminar columnas.***

-   ***Filter: Sirve para seleccionar filas.***

# FILTER

Filter es FILTRAR. Su función es la de **escoger filas** que cumplan algunas condiciones.

Algo muy utilizado es \*\*Filter\*\*, pues permite crear subconjuntos de observaciones (filas) de la muestra, sujetos a alguna condición para las variables.

\* Algunos operadores numéricos que se pueden usar aqui son:

-   **\`\>\`, \`\<\`** mayor que , menor que

-   **\`\>=\`, \`\<=\`** mayor o igual, menor o igual

-   **\`!=\`**, diferente,

-   **\`==\`** igual

\* Operadores booleanos:

-   \`**&**\` and "**y"** (intersección)

-   \`**\|**\` or "**o**" (unión)

-   \`**!\`** no "**no**" (negación)

Por ejemplo:

De la base DatosDiversos ==\> **DDP1** (data Frame de prueba con las ultimas columnas eliminadas)

DDP1 ==\> hasta aquí se ha mejorado lo siguiente:

Tipo de variable; cambio de títulos de columna; ya eliminado las columnas inútiles.

```{r}
DDP1
```

1\) Seleccionar a todos los estudiantes que están en sección 2.

```{r}
Sec2<- filter(DDP1, Sección == "2")
Sec2
```

La fija:

**Hallar la edad promedio de los alumnos de la sección 2.**

solución.

#### Formating

```{r}
Sec2$Edad <- as.numeric(Sec2$Edad)
```

Primero selecciono a los alumnos de la sección 2 (ya lo hice, arriba con FILTER) ==\> son 265 alumnos.

Ahora ya se puede hallar su promedio de edad:

```{r}
M<-mean(Sec2$Edad)
M
```

La edad promedio en la sección 2 es 19.64 años.

&&&&&&&&&&&&&&&

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

**Estatura promedio en Sec 3**

Primero filtrar a la sección 3:

```{r}
Sec3<- filter(DDP1, Sección == "3")
Sec3
```

hay 279 estudiantes en sección 3.

Ahora su estatura:

```{r}
Sec3$`Estatura (cm)` <- as.numeric(Sec3$`Estatura (cm)`)
```

```{r}
mean(Sec3$`Estatura (cm)`, na.rm=T)
```

La estatura promedio es 142.1109 cms.

Comprobamos que hay NAs:

```{r}
summary(DDP1$`Estatura (cm)`)
```

2\) Seleccionar las observaciones con `edad menos de 30` **y** `con estatura por lo menos 1.70 m`.

Nota: **Y**==\> **&** o también puede ser solo una ***coma.***

```{r}
filter(DDP1, Edad<30 , "Estatura (cm)" >= 170)
```

le ponemos un nombre:

```{r}
EDYEST<- filter(DDP1, Edad<30 , "Estatura (cm)" >=170)
EDYEST
```

La desviación estándar **de los pesos** de esos alumnos:

```{r}
sd(EDYEST$`Peso (kg)`, na.rm= TRUE)
```

la desviación estándar de los pesos de estos alumnos es 10.9695 kg.

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

De nuestra Data de trabajo que es DDP1:

```{r}
summary(DDP1$Edad)
summary(DDP1$`Estatura (cm)`)
summary(DDP1$`Peso (kg)`)
```

**DIAGRAMA DE CAJAS:**

Es una gráfica que lleva 5 números importantes:

**Mínimo, Q1, Me, Q3, Máximo.**

Diagrama de cajas de la EDAD:

Aquí se tiene un **diagrama vertical.**

```{r}
table(DDP1$Edad, useNA = "always")
DDP1$Edad <- as.numeric(DDP1$Edad, na.rm = T)
```

```{r}
boxplot(DDP1$Edad)
```

Aquí se tiene un **diagrama horizontal.**

```{r}
boxplot(DDP1$Edad, horizontal = TRUE)
```

Para calcular los 5 valores de un diagrama de cajas, se usa `samary.`

```{r}
summary(DDP1$Edad)
sqrt(var(DDP1$Edad, na.rm = T))
```

**Detalles del diagrama de cajas:**

Las bolitas son DATOS ATÍPICOS O PUNTOS DISCORDANTES o Outliers (son datos muy alejados de la mayoría).

La bolita o punto que está mas a la derecha , **es el MÁXIMO.**

La bolita o punto que está mas a la izquierda , **es el MÍNIMO**.

El rectángulo sombreado es **LA CAJA**.

El lado izquierdo de la caja sombreada, es el Q1 (contiene 25% a la izquierda)

El lado derecho de la caja sombreada es el Q3. (contiene 25% a la derecha)

la raya vertical gruesa, que está adentro de la caja **es la MEDIANA.**

El ancho de la caja sombreada contiene al 50% de los datos. Su longitud se llama **RANGO INTERCUARTÍLICO** ==\> Ancho de caja= RIC = Q3 - Q1.

La longitud horizontal ( en este gráfico) desde el punto mas a la izquierda hasta el punto mas a la derecha se llama :**RANGO TOTAL** = MAXIMO - MINIMO

NOTA: Los valores numéricos del diagrama de cajas se obtienen con SUMMARY

```{r}
summary(DDP1$Edad)
```

Nota:

**En UTEC:**

$$
\text{fracción de dispersión}=\frac{RIC}{RT}=\frac{Q3-Q1}{Max - min}
$$

Para la edad:

$$
FD=\text{fracción de dispersión}=\frac{RIC}{RT}=\frac{2}{40}=0.05
$$

Si FD\<=0.30 ==\> Datos homogeneos. (baja dispersion)

Si 0.30 \< FD \<= 0.60 ==\> Datos regulares (dispersion moderada)

Si FD \> 0.60 ==\> Datos Heterogéneos ( Alta dispersión).

Aqui la EDAD tendria una **fracción de dispersión homogénea**.

&&&&&&&&&&&&&&&&&&&

&&&&&&&&&&&&&&&&&&&&&

ojo:

Obtener de DDP1 a todos los estudiantes que tienen edad mínima 50 años

Nombres de columnas:

```{r}
names(DDP1)
```

"mayor o igual": \>= 50

```{r}
E50<-filter(DDP1, Edad>=50)
E50
```

Hay 6 estudiantes o 6 casos o 6 observaciones que corresponden a alumnos con por lo menos 50 años.

Diga ¿cuál es la edad promedio de estos alumnos?

```{r}
round(mean(E50$Edad), 2)
```

Otros ejemplos: (Preparándome para la masacre del Q1)

1\) *¿cual es la edad máxima del 50% de los que tienen menores edades, en el grupo de los que pasan de 30 años?*

Solución:

Primero escojo a los mayores de 30 años

```{r}
E30<-filter(DDP1, Edad > 30)
E30
```

Hay 12 estudiantes con edades mayores de 30 años.

```{r}
median(E30$Edad)
```

La edad máxima sería 47.5.

*2) ¿Cuál sería la edad mínima del 75% de las mayores edades entre los que tienen mas de 30 años?*

Menor edad —— - - 25%- - ———-**Q1** ——————– - - - 75% — – - - ———-Mayor edad

primera forma:

```{r}
quantile(E30$Edad, 0.25)
```

Segunda forma:

```{r}
summary(E30$Edad)
```

La edad mínima será 37.75 años.

3\) ¿cuál es el promedio del tiempo de reacción entre estos estudiantes? (entre los mayores de 30)

```{r}
#glimpse(E30)
E30$`Tiempo de reacción`<- as.numeric(E30$`Tiempo de reacción`)
```

```{r}
mean(E30$`Tiempo de reacción`, na.rm=TRUE)
```

4\) ¿cuál es el coeficiente de variación de las edades de estos estudiantes? (los mayores de 30)

```{r}
B<-mean(E30$Edad)
A<-sd(E30$Edad)
CV<-A/B
"desviación estándar"
A
"media"
B
"coeficiente de variación"

round(CV, 2)
```

El coeficiente de variación es 0.19

\#########################################################################

CONTINUACIÓN DE LA LIMPIEZA:

**Ejemplos de respuestas que dan los encuestados:**

Amigo (a) ¿almorzaste ya?

si, no, SI, Si, No , NO, Sí, Nó, nooooo, manan, not, **xx, ,** claro, ...etc

Observar en la variable Signo del Zodiaco ¿que respuestas diferentes hay ?

#### Comando **\`*unique*\`**:

Para saber todos los nombres , respuestas o palabras diferentes que hay en una columna:

```{r}
names(DDP1)  # para ver como está escrito el nombre de la columna
```

También glimpse sirve para ver los nombres de las columnas ( y tambien su tipo de variable)

```{r}
glimpse(DDP1)
```

Ahora sí, para ver todas las respuestas distintas que han dado en la columna Zodiaco:

```{r}
DDP1 <- rename(DDP1, Zodiaco =`Signo del zodiaco`)
unique(DDP1$Zodiaco)  # aquí se ve solo las respuestas distintas de Zodiaco.
```

ahora, cuantas respuestas distintas dieron en Sexo (Del DNI):

```{r}
unique(DDP1$Sexo)
```

ahora, cuantas carreras distintas hay en UTEC?

```{r}
unique(DDP1$Carrera)
```

3\) Calcular el peso promedio de los alumnos con *edad menos de 18* y con *signo del toro.*

Primero veamos cuantas respuestas se asemejan a Tauro:

```{r}
unique(DDP1$`Zodiaco`)
```

Se encontró solo 4 respuestas equivalentes a Tauro:

```         
"Tauro" "tauro" "TAURO" "tauri" 
```

```{r}
EdadyZodiaco<-filter(DDP1,Edad <18, (`Zodiaco` == "Tauro" | `Zodiaco` == "tauro" | `Zodiaco` == "tauri"| `Zodiaco` =="TAURO"))

EdadyZodiaco
```

El peso promedio de este grupo de personas:

```{r}
EdadyZodiaco$`Peso (kg)` <- as.numeric(EdadyZodiaco$`Peso (kg)`, na.rm = T)
mean(EdadyZodiaco$`Peso (kg)`)
```

El peso promedio de estos alumnos es 66.81 kg

4\) Seleccionar personas de 18 o 21 o 23 años que sean del signo del toro:

```{r}

EdyZod<-filter(DDP1, (Edad ==18 | Edad == 21 | Edad == 23), ( `Zodiaco`== "tauro" | `Zodiaco`=="Tauro" | `Zodiaco`== "tauri" )|`Zodiaco`== "TAURO")
EdyZod
```

pero también puede usarse el argumento \`***%in%\`*** (pertenece) el cual funciona como una reducción de varios operadores lógicos "or".

```{r}
Edadysigno<- filter(DDP1, Edad %in% c(18,21,23),  `Zodiaco` %in% c("tauro", "Tauro", "tauri", "TAURO"))

Edadysigno
```

Con los alumnos de esta última data, se ha seguido un programa nutricional para aumentar su peso. Se ha visto que aumentaron un 5% y ademas luego de ello tomaron una vitamina que hizo que aumenten todos en 0.5 kg mas. Halle el coeficiente de variación del peso final de estos alumnos. Dar la respuesta en porcentaje con dos decimales.

X: peso inicial

Y: peso final ( siguiendo el programa nutricional)

Y=X+0.05X+0.5 ==\> Y=1.05X+0.5

$$
\overline{X}=?\\
S(X)=??\\
\overline{Y}=1.05*\overline{X}+0.5\\
S(Y)=1.05*S(X)
$$

Hallemos la media y desviación de X (pesos de Edadysigno)

```{r}
Edadysigno$`Peso (kg)`<- as.numeric(Edadysigno$`Peso (kg)`)
```

```{r}
B<-mean(Edadysigno$`Peso (kg)`, na.rm=TRUE)
A<-sd(Edadysigno$`Peso (kg)`, na.rm=TRUE)
"desviación estándar"
A
"media"
B
```

Nuevo promedio: 1.05\*(67.37895)+0.5

Desviación nueva: \|1.05\|\*12.45774

```{r}
CV<- (1.05*A)/(1.05*B+0.5)
CV

paste(round(100*CV, 2),"%")
```

&&&&&&&&&

&&&&&&&&&&

5\) Se desea seleccionar personas que midan **al menos 175 centímetros** y su talla de polo sea al menos L.

```{r}
unique(DDP1$`Talla de polo`)  # Para ver todas las respuestas distintas de la variable.
```

Tallas al menos L: Se debe considerar las tallas: XXL, L, XL, l, xl, Xl,L-XL, XXXL.

Al menos L = "L o más grande".

Talla al menos L: **XXL, L, XL, l, xl, Xl,L-XL, XXXL**

```{r}
names(DDP1)
DDP1 <- rename(DDP1, Estatura_cm = "Estatura (cm)", Peso_Kg="Peso (kg)")
```

```{r}

TPL<-filter(DDP1, Estatura_cm >= 175,`Talla de polo` %in% c("XXL", "L","XL", "l",  "xl","Xl", "XXXL", "L-XL") )

TPL
```

Son 226 alumnos de este tipo.

Halle la máxima estatura del 50% de las menores estaturas de los alumnos filtrados en el anterior

**min estatura...............50% ................Me**............50%............max. estatura.

hallaré su mediana

```{r}
median(TPL$Estatura_cm)
```

¿Cuál será la Sección de moda de este ultimo DF?

```{r}

table(TPL$Sección, useNA = "always")
```

Se observa que hay secciones desde: 1 hasta 15.

Las mayores frecuencias son:

Sección 1 ==\> (1 o 1.01) ==\> 32 alumnos

Sección 2 ==\> 31 alumnos

MODA= sección 1. Frecuencia modal = 32.

6\) Seleccionar alumnos que tengan edad 19 o 20 o 52 años y ***que hayan respondido su peso***.

Para que hayan respondido su peso, en esta columna se se debe **ignorar a los NA** .

```{r}
# Filtramos a todos los alumnos que han respondido algo en Peso.

filter(DDP1, Edad %in% c(19, 20, 52), Peso_Kg != "NA")  # se coloca "diferente" mediante:   ! =
```

7\) Seleccionar a los alumnos que no llenaron su edad ( hay NA)

```{r}

filter(DDP1, Edad ==  "NA")    # pero esto no está bien.
```

Debe hacerse así: (lo correcto)

```{r}
filter(DDP1, is.na(DDP1$Edad))
```

***Para seleccionar a aquellos que si llenaron sus datos se pone `Edad ! = "NA"`.***

***Para seleccionar a aquellos que no llenaron sus datos se coloca `is.na(columna)`***

```{r}
# ¿Cuántos alumnos habrán llenado su talla de zapatos?

filter(DDP1, `Talla de zapato` !="NA")  # Si llenaron algo en "talla de zapato"
```

Son 2257 alumnos.

9\) Seleccionar a personas de la sección 4 del último periodo académico del 2024.

primero vemos las diversas respuestas de Periodo:

```{r}
unique(DDP1$Período)
```

Usamos \`unique\` para ver todas las respuestas que dieron en Periodo:

Solo interesa aquellos que escribieron:

Ahora ya lo podemos filtrar

```{r}

PQ<- filter(DDP1, Sección == "4", Período %in% c("2024-2", "2024.2", "2024 -2"))
PQ
```

Hay 26 alumnos.

\#############################################################################################

10\) Calcular el coeficiente de variación de la edad de los alumnos de sección 4 y del último periodo del 2024.

```{r}
CV<- sd(PQ$Edad, na.rm=T)/mean(PQ$Edad, na.rm=T)
CV

```

11\) Seleccionar a las personas q***ue no han respondido en Signo del Zodiaco*** y son mayores de 20 años

```{r}
filter(DDP1, is.na(`Zodiaco`), Edad >20)
```

12\) Seleccionar a las personas que no han respondido en Signo del Zodiaco, menores de 20 años y que han respondido su peso.

```{r}

filter(DDP1, is.na(Zodiaco), Edad <20, Peso_Kg != "NA")
```

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

# El paquete dplyr:

Dplyr consta de 5 funciones principales que nos van a ayudar a la hora de manipular nuestra informacion:

-   Filtrado de informacion y datos a traves de **filter(),** por filas.

-   Reordenar las filas con **arrange()**

-   Escoger variables (columnas) con **select()**

-   Crear nuevas variables con funciones existentes a traves de **mutate()**

-   Agrupar datos con **summarize()**

Todas estas funciones se pueden utilizar en conjunto con **group_by()**, que se centra en la agrupacion de datos.

Ademas, todas siguen un mismo patron de uso:

-   El primer argumento siempre es el data frame con el que vamos a trabajar

-   El siguiente argumento define la accion que queremos llevar a cabo (dplyr)

-   El resultado es un nuevo data frame

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

**CORRECCIÓN DE RESPUESTAS**

Se usará **DFT** (Data Frame de Trabajo), que es el data frame **DDP1**

Hacemos una copia de DDP1:

```{r}
DFT<- DDP1
DFT   # Data Frame de Trabajo
```

Trabajamos con **DFT:**

*Corrigiendo los datos de la columna **SEXO:***

Usamos ***unique*** para ver todas las respuestas de la columna:

```{r}
unique(DFT$Sexo)
```

**NOTA:** Son diferentes en R: **" F", "F", " F ","F "**

Corregiremos las respuestas que \*\*evidentemente están mal escritas\*\*, en esta columna.

**1)** *Primero se debe eliminar espacios en blanco en los extremos de las respuestas (datos) mal escritas:* **" F"** que no es igual a **"F"** y no es igual **"F"** y distinto de **" F "**

Se usa el paquete ***stringr***, el cual sirve para manipular caracteres y expresiones regulares; viene incluido en tidyverse. Previo se debe haber cargado el paquete *tidyverse*

primero cargar la libreria:

```{r}
library(stringr)
```

ahora se usará de aquí el comando: \`***str_trim***\`

Como vamos a corregir la variable Sexo, vamos a asignar un nuevo nombre a la base de datos

Usamos table para ver como está distribuido la variable Sexo:

```{r}

table(DFT$Sexo, useNA = "always")
```

ahora si, eliminemos los espacios en blanco innecesarios en los extremos, que podría haber en las respuestas de Sexo

```{r}

DFT$Sexo<- str_trim(DFT$Sexo, side="both")
table(DFT$Sexo, useNA = "always")
```

**quedó igual, pues en las respuestas de Sexo, no había espacios en blanco en los extremos de cada respuesta.**

2\) *Para pasar todo a minúsculas* (***tolower***) o *todo a mayúsculas* (***toupper***):

**Todo a minúsculas:**

```{r}
DFT$Sexo<- tolower(DFT$Sexo)  # puede ponerse con un nombre nuevo y estaría como vector
DFT

```

```{r}

table(DFT$Sexo, useNA = "always")
```

Así tambien:

```{r}
Sexmin<- tolower(DFT$Sexo)
Sexmin
table(Sexmin)
```

*Se puede pasar todo a mayúsculas:*

```{r}
DFT$Sexo<- toupper(DFT$Sexo)
DFT
```

o tenerlo como un vector:

```{r}
Sexmay<- toupper(DFT$Sexo)
table(Sexmay)
```

**No usar lo siguiente:**

((Pero si *se desea ir modificando la columna de la misma base de datos,* usar para pasar a minúsculas:

`DFTS$Sexo<- str_to_lower(DFTS$Sexo) table(DFTS$Sexo)  DFTS}`

`DFTS$Sexo<- str_to_upper(DFTS$Sexo) table(DFTS$Sexo) DFTS}))`

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

3\) Ahora modificamos la escritura de aquellas respuestas que son evidentes mal escritas:

Con \`***mutate\`*** se crea nuevas columnas y se guarda al final de la base de datos.

***mutate*** corrige las respuestas erradas y los coloca en una nueva columna, al final.

```{r}
#Usaremos: M= masculino, F= femenino
DFT<-mutate(DFT, Sexcor = case_when(Sexo == 'NA' ~ 'NA',                                                                   Sexo == 'MM' ~ 'M',                                                                    Sexo == 'NB'~'desconocido',                                                            Sexo == 'M'~'M',                                                                       Sexo == 'F'~'F',                                                                       Sexo == 'L'~'desconocido',                                                             Sexo == '125'~ 'desconocido',                                                          Sexo == '´M' ~ 'M')) 
DFT
```

veamos mejor

```{r}

table(DFT$Sexcor, useNA = "always")
```

**Variable Sexo** ==\> Ya corregida. Ya está limpia.

\######################################

***Transmute:***

Cambiemos de nombre a DFT

```{r}
DX<- DFT
DX  # para experimentar en esta nueva data DX
```

```{r}
table(DX$Sexo)
```

Ahora

```{r}
DX$Sexo<-transmute(DX, Sexo= case_when( Sexo == 'NA' ~ 'NA',                                                                   Sexo == 'MM' ~ 'M',                                                                    Sexo == 'NB'~'desconocido',                                                            Sexo == 'M'~'M',                                                                       Sexo == 'F'~'F',                                                                       Sexo == 'L'~'desconocido',                                                             Sexo == '125'~ 'desconocido',                                                          Sexo == '´M' ~ 'M')) 

```

```{r}
DX
```

```{r}
table(DX$Sexo, useNA = "always")
```

```{r}
DX$Sexo 
```

```{r}
table(DX$Sexo, useNA = "always")
```

\############################################################

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

# DESCRIPTORES GRÁFICOS

### GRAFICO DE CUALITATIVOS:

Tomamos la columna **Sexcor**

```{r}
DFT
```

```{r}

table(DFT$Sexcor, useNA = "always")
```

Copiando las frecuencias

```{r}
frec<- c(4, 828, 1963, 114) # es un vector  que copia las frecuencias de table
frec
```

Hagamos un ***gráfico circular*** de *Sexcor*.

```{r}
pie(frec)  # se forma un diagrama circular
```

*con sus frecuencias:*

```{r}
pie(frec, labels = frec)
```

*con una leyenda:*

```{r}
pie(frec, labels= frec)
legend("topleft", legend = c("Desconocido", "Femenino", "Masculino", "NA"), fill= c("white", "lightblue","mistyrose", "skyblue"))
```

```{r}

pie(frec, labels=frec, col= c("white", "blue", "yellow", "green")) 

legend("topleft", legend = c("Desconocido", "Femenino", "Masculino", "NA"),                fill =  c("white", "blue", "yellow","green"))

```

Instalar el nuevo paquete:

```{r}

#install.package("plotrix")
```

Cargando su libreria:

```{r}
library(plotrix)
```

y ahora en 3D ==\> pie3D

```{r}

pie3D(frec, labels=frec, col= c("white", "blue", "yellow", "green")) 
legend("topleft", legend = c("Desconocido", "Femenino", "Masculino", "NA"),      fill =  c("white", "blue", "yellow","green"))
```

finalmente el título:

```{r}

 pie3D(frec, labels=frec, col= c("white", "blue", "yellow", "green"))
 legend("topleft", legend = c("Desconocido", "Femenino", "Masculino", "NA"),  fill =  c("white", "blue", "yellow","green")) 
 title("Gráfico circular de la variable Sexo Corregido")
 
```

Diagrama circular es ideal para variables cualitativas, pero tambien se puede usar en cuantitativas discretas, pero que tengan pocos valores distintos.

## DIAGRAMA DE CAJAS

*Se hace para cuantitativas.*

Un diagrama de cajas, contiene la información resumida en base a 5 números importantes:

Mín, Cuartil 1, Mediana, Cuartil 3, Máx.

**Min---------Q1-----------Me------Q3-------Max.**

Diagrama de cajas para la variable EDAD:

```{r}
boxplot(DFT$Edad)
```

El punto mas alto ==\> máximo

El punto mas bajo = mínimo

La raya negra que está en el rectángulo: mediana

Cada bolita representa a datos atípicos (poco frecuentes)

Las lineas horizontales que forman la caja (rectángulo sombreado) son Q1 y Q3

Las bolitas representa valores atípicos.

```{r}
summary(DFT$Edad)
```

Min=15.....Q1=18......Me=19.....Q3=20....Max=53

con color y horizontal:

```{r}

boxplot(DFT$Edad, col="yellow", horizontal = TRUE)
summary(DFT$Edad)
```

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Aquí existe varios puntos (bolitas en blanco) que están muy distanciado o aislados del resto de puntos y se les llama: valores *extremos* o puntos *outliers*. o puntos *discordantes* o *atípicos.*

con los puntos:

```{r}

boxplot(DFT$Edad, col="yellow", horizontal = TRUE , xlab ="Edad en años") 
stripchart(DFT$Edad, method = "jitter", pch = 19, add = TRUE, col = "red")
```

con stripchart se logra graficar mediante puntos, a los datos numéricos que se tenía.

Para saber que cantidad hay , en cada bolita blanca, puedes usar table.

```{r}
table(DFT$Edad, useNA="always")
```

**NOTAS:**

1)  La media es muy susceptible a los valores extremos.

2)  Cuando hay presencia de valores extremos, se prefiere la mediana.

    1)  Cuando hay una simetría muy notoria, es decir hay presencia de valores extremos, se prefiere la mediana como valor mas representativo.

3)  Cuando no hay valores extremos conviene usar la media.

    1)  Cuando no hay valores extremos o cuando hay una gráfica cerca a la simetría, conviene usar la media.

## BOXPLOT INDEXADO:

Sirve para realizar comparaciones en simultáneo entre **los valores numéricos de una variable**, *para diferentes categorías de otra variable*:

Por ejemplo , de la data DFT, comparamos las **edades por géneros** en diagrama de cajas:

```{r}
boxplot(DFT$Edad~DFT$Sexcor, horizontal = T, col="yellow")
# se coloca primero la numérica (Edad) y luego la Cualitativa (Sexcor)
```

\*\*Cuando al hacer Boxplot indexado, los diagramas son muy similares entonces hay independencia entre las variables. Si hay mucha diferencia entre los gráficos del bloxplot indexado, ... revisa info de la grabación \[21-01\]

```{r}
MM<-filter(DFT, Sexcor=="M")
MM
FF<-filter(DFT, Sexcor=="F")
FF
XX<-filter(DFT, Sexcor=="desconocido")
XX
```

```{r}
summary(MM$Edad)
summary(FF$Edad)
summary(XX$Edad)
```

![](images/clipboard-9133593.png)

También puede ser:

```{r}
boxplot(Edad~Sexcor, DFT, horizontal = T, col="pink")
```

#### Otro ejemplo

Utilizando solo las filas completas, haga un boxplot indexado entre talla de zapato por sexo

```{r}
Filascomp$`Talla de zapato` <- as.numeric(as.character(Filascomp$`Talla de zapato`))

boxplot(`Talla de zapato` ~ Sexcor,
        data = Filascomp,
        horizontal = TRUE)

```

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Tipos de variable:

Cualitativas

Cuantitativas

Uso de \*\*Factor\*\*:

Las variables cualitativas pueden quedar muy bien definidas como datos categóricos si se transforman a factor:

```{r}
Fsexcor<-factor(DFT$Sexcor) 
Fsexcor
```

ahora recién se puede usar para hacer algunos gráficos:

### **PLOT**:

Hace un diagrama formado por rectángulos (barritas verticales) , si es que la variable es factor (cualitativos).

Plot si acepta variable numérica y lo que origina es un diagrama del tipo "dispersión".

```{r}
plot(DFT$Edad) # aqui la variable es cuantitativa (no es necesario pasar a factor) y produce una nube de puntos.
```

Esta gráfica se llama Diagrama de dispersión.

Plot básico de la variable Sexo corregido, visto como factor:

```{r}

plot(x=Fsexcor) # aqui mi variable es cualitativa (ya convertida en modo FACTOR).
```

Recordar que se tiene TABLE para ver las frecuencias de cada categoría.

```{r}
table(DFT$Sexcor)
```

Plot editado:

```{r}

plot(x = Fsexcor, main = "Gráfico de barras para la variable Sexo",  xlab = "Sexo", ylab = "Frecuencia absoluta",  col = c("white", "yellow", "royalblue"))
```

otra forma es con:

### Barplot

```{r}

tabsexo<-table(DFT$Sexcor, useNA = "always") # la información de resumen de sexcor, se coloca en la tabla tabsexo.   
tabsexo
barp<- barplot( tabsexo,main="Gráfico de barras de Sexo",col=c("white", "yellow", "red","green"),xlab = "Sexo", ylab = "Frecuencia absoluta")
```

ahora con algunos detalles mas

```{r}

tabsexo<-table(DFT$Sexcor,useNA = "always") # la información de resumen de sexcor, se coloca en una tabla y se asigna un nombre 
tabsexo
barp<- barplot( tabsexo,main="Gráfico de barras de Sexo",col=c("white", "yellow", "red","green"),xlab = "Sexo", ylab = "Frecuencia absoluta" )
text(barp, tabsexo + 0.5, labels = tabsexo)
grid(nx = NA, ny = NULL, lwd = 1, lty = 1, col = "gray")
```

mejoramos los valores sobre cada rectángulo:

```{r}

tabsexo<-table(DFT$Sexcor,useNA = "always") # la información de resumen de sexcor, se coloca en una tabla y se asigna un nombre 
tabsexo
barp<- barplot( tabsexo,main="Gráfico de barras de Sexo",col=c("white", "yellow", "red", "green"),xlab = "Sexo", ylab = "Frecuencia absoluta",ylim=c(-200,2000) ) 
text(barp, tabsexo + 0.5, labels = tabsexo)  
grid(nx = NA, ny = NULL, lwd = 1, lty = 1, col = "grey")
```

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

# Histogramas

Obligatorio, esta gráfica es para variables cuantitativas (numéricas)

Solo para variables numéricas y generalmente es para variables continuas.

También se usa cuando la variable es discreta, pero que tome una gran cantidad de valores diferentes.

Vamos a corregir Estaturas

&&&&&&&&&&&&&&&&&&&&&&&&&&&

&&&&&&&&&&&&&&&&&&&&&&&&&&&

**Corrigiendo la variable Estatura**

-   *Para corregir **una variable cualitativa,** lo primero es usar TABLE o también UNIQUE.*

-   Para corregir una cuantitativa, lo primero es usar SUMMARY.

```{r}
summary(DFT$Estatura_cm, na.rm=TRUE)
```

Se observa:

Minima estatura= 1.0 cm (está mal. Debe haber intentado decir que su estatura es 1m)

Máxima estatura= 1653 cm (esta mal. Ha intentado decir que su estatura es 165.3 cm = 1.653 m)

Previamente con el comando \`summary\` se detectó errores del tipo: personas que medían menos de 2 centímetros, lo cual evidenciaba que la intención era poner 1.xx metros y no 1.xx centímetros, lo cual se puede arreglar multiplicandolo por 100; también hay personas que han puesto una estatura en mas de 1600 cms.

Tomaremos **estaturas en el aula** que varían entre 100 centímetros y menores de 220 centímetros ( es un criterio tomado para la sección)

Tomaremos un criterio para las estaturas:

```{r}
filter(DFT,Estatura_cm<100 | Estatura_cm>220)
```

se observa que hay varias personas cuyas estaturas lo expresaron en metros, lo cual debe corregirse para que la estatura quede expresada en centímetros. Se corrige por 100.

Corrigiendo a los de menor estatura:

```{r}
DFT<-mutate(DFT, Estcor = ifelse(Estatura_cm<2, 100*Estatura_cm, Estatura_cm))
DFT
```

```{r}
summary(DFT$Estcor)
```

Analizando nuevamente:

```{r}
DFT<-mutate(DFT, Estatcor= ifelse(Estcor<100, 10*Estcor, Estcor))
DFT
```

```{r}
summary(DFT$Estatcor)
```

Si alguien escribió 1653 cm ha querido escribir: 165.3 cm

Por ello hacemos

```{r}
DFT<-mutate(DFT, Estaturareal = ifelse (Estatcor> 1000 , 0.1*Estatcor, Estatcor))
DFT
```

```{r}
summary(DFT$Estaturareal)
```

Pondremos ahora una estatura máxima de 220 cm.

```{r}
DFT<-mutate(DFT, EstaturaCorr =ifelse(Estaturareal <220, Estaturareal, NA))
DFT
```

```{r}
summary(DFT$EstaturaCorr)
```

la estatura ya esta corregida y limpia.

```{r}
hist(DFT$EstaturaCorr)
```

AHORA YA SE TIENE DOS COLUMNAS CORREGIDAS: SEXO Y ESTATURA.

\#########################################

Veamos un diagrama de cajas con la Estatura ya corregida:

```{r}
boxplot(DFT$EstaturaCorr, horizontal = T)
```

Podemos tomar una decisión que reduzca a los valores extremos (atípicos)

```{r}
 EstatsinExtr<-filter(DFT,EstaturaCorr>=130 & EstaturaCorr<=200)
 EstatsinExtr
```

Ahora ya se puede hacer su histograma;

```{r}
hist(EstatsinExtr$EstaturaCorr)
```

Mejoramos a este diagrama:

```{r}

hist(DFT$EstaturaCorr, xlab = "Estaturas de alumnos", ylab = "frecuencia absoluta", col ="green" , main="Histograma de las Estaturas usuales, de alumnos UTEC"  )
```

\*\* cambiando el numero de intervalos \*\*

```{r}
hi<-hist(DFT$EstaturaCorr, xlab = "Estaturas de alumnos", ylab = "frecuencia absoluta", col ="blue" , border= "red" , main="Histograma de Estaturas bien escritas de alumnos UTEC", breaks=12 )
```

Observando las alturas

```{r}
hi<-hist(DFT$EstaturaCorr, xlab = "Estaturas de alumnos", ylab = "frecuencia absoluta", col =c("white", "blue","white","blue","white","blue"), border= "red" , main="Histograma de Estaturas bien escritas de alumnos UTEC", breaks=10  ) 
text(hi$mids,hi$counts,labels=hi$counts, adj=c(0.1, -0.1), cex=0.5)
```

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
